# LLMContextGenerator AI 协作开发规则
## LLM Collaboration Protocol v0.1.1

---

# 一、核心理念

## 1.1 Vibe Development 哲学

> **最珍贵的是对话过程本身，不追求直接出结果，而是步步为营共同规划。**

本项目采用 **Vibe Development** 模式：
- AI 不是执行者，而是协作伙伴
- 不急于产出代码，先对齐理解
- 每个决策都是共同思考的结果
- 对话本身就是设计过程的一部分

## 1.2 决策质量观

> **大量决策，90% 正确率，关键决策零失误**

项目是一系列决策的集合：
- 只有做对 90% 以上的决策，项目才有望成功
- 关键决策容错数: 0
- 因此每个 S/A 级决策都需要 **人机共同 Review**

## 1.3 长期对话工程观

这是一个**长期对话工程**，不是一次性任务：
- 对话是连续的，上下文需要被**持久化保存**
- 每次对话都在前次基础上**迭代推进**
- Git 提交历史记录了**思维演进过程**
- CONTRIBUTING_AI.md 是**活文档**，随项目成长

---

# 二、职能角色定义

本项目模拟多职能协作，AI 在对话中切换不同角色视角：

| 角色代号 | 职能 | 关注点 | 触发词 |
|---------|------|--------|--------|
| `[DESIGN]` | 协议设计 | Schema设计、协议演进、用户体验 | "设计"、"协议"、"Schema" |
| `[ARCH]` | 架构 | 模块结构、扩展机制、性能 | "架构"、"重构"、"模块" |
| `[DEV]` | 开发 | 功能实现、Bug修复 | "开发"、"实现"、"代码" |
| `[PM]` | 项目管理 | 里程碑、发布、优先级 | "规划"、"发布"、"里程碑" |
| `[QA]` | 产品质量保证 | 验收测试、用户体验验证 | "验收"、"体验测试" |
| `[TEST]` | 单元测试 | pytest、覆盖率 | "单元测试"、"pytest" |

**使用方式**: 在对话中明确指定角色，或让 AI 自动识别并标注当前角色视角。

## 2.2 QA 角色的特殊地位

> **QA 是每个功能的最后守门人，无验收则不算完成**

QA 职能贯穿整个开发流程：
- **开发前**: 参与需求评审，提出测试视角问题
- **开发中**: 准备测试用例框架
- **开发后**: 执行验收测试，确认功能符合预期

---

# 三、决策分级制度

## 3.1 决策等级

| 等级 | 类型 | 影响范围 | Review 要求 |
|-----|------|---------|------------|
| **S** | 战略决策 | 整体方向、核心功能 | 必须人工确认，记录决策理由 |
| **A** | 架构决策 | 系统设计、数据结构 | 人工Review，可异步确认 |
| **B** | 实现决策 | 具体方案选择 | AI 提出建议，人工可快速确认或默认通过 |
| **C** | 细节决策 | 参数、命名、格式 | AI 自主决策，事后可调整 |

## 3.2 决策记录格式

```markdown
## DECISION-{序号}: {标题}
- **等级**: S/A/B/C
- **角色**: [角色代号]
- **问题**: {需要决策的问题}
- **选项**: 
  - A: {选项A}
  - B: {选项B}
- **决策**: {最终选择}
- **理由**: {为什么这么选}
- **日期**: {YYYY-MM-DD}
- **状态**: PENDING / CONFIRMED / REVISED
```

---

# 四、开发流程协议

## 4.1 任务单元定义

开发不按日期，按 **对话任务单元** 推进：

```
任务单元 (Task Unit):
├── ID: TASK-{role}-{seq}
├── role
├── feature
├── dependencies
├── output
├── status
├── dialogue_rounds
└── 状态: TODO / IN_PROGRESS / REVIEW / DONE
```

## 4.2 标准对话流程

### 4.2.0 对话开始时（强制）

> **每次新对话开始，AI 必须先恢复当前状态**

```
1. 读取 docs/CONTEXT.md
2. 读取 CONTRIBUTING_AI.md
3. 了解当前进度
3. 确认用户本次对话目标
```

**项目初始化约束**：
- 如果是新项目且没有 `.git` 目录，必须执行 `git init` 初始化 Git 仓库
- 初始化后立即执行首次提交：`git add -A && git commit -m "init: 项目初始化"`
- Git 是协作记录的基础，没有 Git 无法进行有效的版本追踪

### 4.2.1 对话结束时（强制）

> **每次对话结束前，AI 必须保存当前状态**

```
1. 更新 docs/CONTEXT.md
2. 更新 docs/CHANGELOG.md
3. Git commit → 记录对话成果
```

### 4.2.2 标准对话中流程

```
1. [人] 提出需求/问题
       ↓
2. [AI] 识别角色，分析问题
       ↓
3. [AI] S/A级决策请求确认，B/C级自主执行 ← 条件: decision_level in [S, A]
       ↓
4. [AI] 执行任务，输出结果
       ↓
5. [AI] 更新测试用例（如为功能开发） ← 条件: task_type == feature
       ↓
6. [AI] 总结进展，提示下一步
       ↓
7. [人] 确认/修正/继续
       ↓
8. [AI] Git 提交记录
```

## 4.2.3 需求澄清协议（重要）

> **用户提出需求时可能是自然无意识的，AI 必须将模糊描述转化为结构化需求**

**触发条件**: 用户提出的需求存在以下情况
- 描述模糊或不完整
- 缺少具体的验收标准
- 可能有多种理解方式
- 涉及 S/A 级决策

**澄清流程**:
```
1. [AI] 识别用户意图，提取关键信息
2. [AI] 转化为结构化需求描述
3. [AI] 列出假设和待确认项
4. [人] 确认/修正/补充
5. [AI] 形成最终需求文档
```

**结构化需求模板**:

```markdown
## 需求: {需求标题}

**原始描述**: 
> {用户原话}

**需求分析**:
- 目标: {要达成什么}
- 场景: {在什么情况下使用}
- 用户: {谁会使用}

**功能要求**:
1. {具体功能点1}
2. {具体功能点2}

**验收标准**:
- [ ] {可验证的标准1}
- [ ] {可验证的标准2}

**待确认项**:
- [ ] {需要用户确认的假设1}
- [ ] {需要用户确认的假设2}

**决策等级**: {S/A/B/C}
**预估复杂度**: {高/中/低}
```

**快速澄清问句**:
- "你希望达到什么效果？"
- "有没有参考案例？"
- "这个功能谁会用？在什么场景下用？"
- "如何验证这个功能是否完成？"
- "有时间或资源约束吗？"

**示例**:

用户说: "加个导出功能"

AI 澄清后:
```markdown
## 需求: 数据导出功能

**原始描述**: 
> 加个导出功能

**需求分析**:
- 目标: 将系统数据导出为文件，便于备份或分享
- 场景: 用户需要离线查看或迁移数据时
- 用户: 所有用户

**功能要求**:
1. 支持导出为 JSON 格式
2. 支持导出为 CSV 格式（如有表格数据）
3. 导出文件包含时间戳命名

**验收标准**:
- [ ] 点击导出按钮后生成文件
- [ ] 文件可被其他工具正常打开
- [ ] 导出内容完整无丢失

**待确认项**:
- [ ] 需要导出哪些数据？全部还是部分？
- [ ] 是否需要导出格式选择？
- [ ] 文件大小有限制吗？

**决策等级**: B
**预估复杂度**: 中
```


## 4.3 迭代建议管理协议（重要）

> **QA 测试中产生的迭代建议，必须经过 PM 评审后决定是否纳入当前里程碑**

**迭代建议来源**:
- QA 测试过程中的体验反馈
- 开发过程中发现的改进点
- 用户/人类的直接建议

**PM 评审流程**:
```
1. 收集 → 记录到 docs/ROADMAP.md "迭代建议池"
2. 评审 → 分析优先级、冲突、成本
3. 决策 → 纳入/延后/拒绝
4. 排期 → 确定开发顺序
5. 执行 → 转为 TASK
```

## 4.4 版本回顾协议（重要）

> **每次新版本规划前，必须回顾上个版本的测试表现和用户反馈**

**回顾时机**: 里程碑验收完成后，开始下一阶段规划前

**回顾内容**:
```
1. 测试表现
   - 通过率、问题分布
   - 稳定性评估
   
2. 用户体验反馈
   - 核心功能验证结果
   - 操作体验、视觉体验
   
3. 技术债务
   - 已知问题表
   - 性能瓶颈
   
4. 迭代建议池
   - 上版本积累的建议
   - 优先级重新评估
```

**产出**:
- 补充新的需求到下一阶段
- 调整任务优先级
- 记录设计决策

## 4.5 构建打包协议（重要）

> **全量验收前必须完成打包流程，打包是开发的一环**

**构建时机**:
- ✅ 里程碑全量验收前
- ✅ Bug 修复期集中测试
- ✅ 准备分发/演示版本
- ❌ 不需要每次提交都构建

**全量验收前 CheckList**:
```
[ ] 1. npm run build
[ ] 2. 双击 dist/index.html 测试
[ ] 3. 确认正常运行
[ ] 4. 更新操作说明（如有新功能）
```

## 4.6 配置级迭代协议（重要）

> **仅修改数值配置、不改动代码逻辑的迭代，可快速执行**

**定义**: 配置级迭代 = 仅调整现有参数值，不增删代码逻辑

**可快速执行的配置示例**:
- 数值参数调整
- 配置文件修改
- 样式/主题变更
- 文案/文本修改

**执行规则**:
1. 用户明确指出"配置调整"或"数值修改"
2. AI 直接修改对应配置值
3. 无需 PM 审批，无需创建 TASK
4. commit 使用 `[CONFIG]` 前缀

**不适用情况** (需 PM 审核排期):
- 需要新增函数/类/文件
- 涉及系统交互逻辑变更
- 可能影响其他模块
- 用户不确定该改什么


## 4.7 QA 验收协议（重要）

> **每个功能完成后，必须同步更新 QA 测试用例，供验收使用**

**QA 测试用例要素**:
- 测试 ID (TC-{module}-{seq})
- 关联功能 (TASK-ID)
- 前置条件
- 测试步骤 (可复现的操作序列)
- 预期结果 (明确、可验证)
- 测试状态

**开发者责任**:
1. 功能完成时，在 `docs/QA_TEST_CASES.md` 添加测试用例
2. 提供清晰的操作步骤和预期表现
3. 标注已知限制或边界情况

**QA 责任**:
1. 按测试用例执行验收测试
2. 记录实际结果和问题
3. 更新测试状态 (通过/部分通过/未通过)
4. **验收失败时**: 附上日志/截图
5. 提交 Bug 到已知问题表

## 4.8 快速验收回复模板

功能开发完成后，AI 必须提供**快速验收清单**，用户可直接复制回复：

```markdown
## 🧪 快速验收

**启动**: `npm run dev`

**验收项**:
- [ ] 功能A: {操作} → {预期}
- [ ] 功能B: {操作} → {预期}
- [ ] 功能C: {操作} → {预期}

**快速回复** (复制修改后发送):
✅ 全部通过
或
⚠️ 问题: {描述问题}
```

**用户回复格式**:
- `✅` 或 `通过` - 全部验收通过，继续下一步
- `⚠️ 问题: xxx` - 有问题需要修复
- `跳过` - 暂不验收，先继续


## 4.3 Git 协作规范

### 分支策略
```
main                 # 稳定版本
├── dev              # 开发主线
│   ├── feature/{特性名}     # 功能开发
│   ├── design/{设计文档}    # 设计迭代
│   ├── refactor/{模块名}    # 重构优化
│   └── fix/{问题描述}       # Bug修复
```

### Commit 前缀
```
[DESIGN]  设计文档变更
[ARCH]  架构调整
[FEAT]  新功能
[FIX]  Bug修复
[CONFIG]  配置调整（不改逻辑）
[REFACTOR]  重构
[DOC]  文档更新
[TEST]  测试相关
[VIBE]  协作流程更新
```

### Git 提交要求（重要）

> **每次有效对话都必须产生 Git 提交，记录思维演进**

Git 历史不仅是代码版本，更是**设计思维的演进记录**。

---

# 五、测试体系

## 5.1 单元测试 (Unit Test)

> **开发者视角：验证代码逻辑正确性**

| 配置项 | 值 |
|-------|-----|
| 测试框架 | jest |
| 覆盖率目标 | 80% |
| 文件模式 | **/*.test.ts, **/*.spec.ts |
| 运行时机 | pre-commit, ci |

**单元测试原则**:
- 每个模块应有对应的测试文件
- 关键函数必须有测试覆盖
- 测试应该独立、可重复
- Mock 外部依赖

## 5.2 产品QA验收 (Product QA)

> **用户视角：验证功能符合预期**

**测试用例文件**: `docs/QA_TEST_CASES.md`

**用例ID格式**: `TC-{module}-{seq}`

**测试用例要素**:
- id
- feature
- precondition
- steps
- expected
- status

**测试状态**:
- 🟢 PASS
- 🟡 PARTIAL
- 🔴 FAIL
- ⚪ SKIP

## 5.3 Unit Test vs Product QA 区别

| 维度 | Unit Test | Product QA |
|------|-----------|------------|
| 视角 | 开发者 | 用户 |
| 目标 | 代码正确性 | 功能完整性 |
| 粒度 | 函数/模块级 | 功能/流程级 |
| 执行 | 自动化 | 可自动+人工 |
| 时机 | 提交时 | 功能完成时 |
| 工具 | 测试框架 | 测试用例手册 |

---

# 六、里程碑定义

## 6.1 里程碑规范

> **里程碑 = 多个特性 + Bug修复期 + 全量验收**

### 里程碑生命周期

```
┌─────────────────────────────────────────────────────────┐
│                   里程碑生命周期                          │
├─────────────────────────────────────────────────────────┤
│  1. feature_dev - 特性开发期
│     └── 所有计划特性完成
│     └── 快速验收通过
├─────────────────────────────────────────────────────────┤
│  2. feature_freeze - 特性冻结
│     └── 不再添加新功能
│     └── 构建成功
├─────────────────────────────────────────────────────────┤
│  3. bug_fix - Bug 修复期
│     └── P0/P1 问题清零
│     └── 测试通过率达标
├─────────────────────────────────────────────────────────┤
│  4. acceptance - 里程碑验收
│     └── QA 全量测试通过
│     └── 单元测试覆盖率达标
│     └── 已知问题清零或标记延后
├─────────────────────────────────────────────────────────┤
│  5. retrospective - 版本回顾
│     └── 回顾测试表现
│     └── 收集用户反馈
│     └── 补充新需求到下一阶段
└─────────────────────────────────────────────────────────┘
```

### Bug 优先级

| 优先级 | 描述 |
|-------|------|
| P0 | 崩溃/阻断 |
| P1 | 功能异常 |
| P2 | 体验问题 |
| P3 | 优化建议 |

### 里程碑 Tag

```bash
git tag -a v{major}.{minor}.{patch} -m "描述"
```

---

# 七、迭代管理

## 7.1 迭代建议管理协议

> **迭代建议必须经过 PM 评审后决定是否纳入当前里程碑**

**决策分类**:
- ✅ 纳入当前里程碑
- ⏳ 延后到下个里程碑
- ❌ 拒绝（不符合方向）
- 🔄 合并其他迭代

**评审维度**:
- 与当前任务的依赖/冲突关系
- 对用户体验的影响程度
- 开发成本和技术复杂度
- 里程碑剩余时间约束

## 7.2 配置级迭代协议

> **仅修改配置、不改动代码逻辑的迭代，可快速执行**

**执行规则**:
- 用户明确指出"配置调整"
- AI 直接修改对应配置值
- 无需 PM 审批，无需创建 TASK
- commit 使用 `[CONFIG]` 前缀

**适用示例**:
- 数值参数调整
- 配置文件修改
- 样式/主题变更
- 文案/文本修改

---

# 八、阶段化协作规则

## 8.1 项目生涯阶段说明

项目开发过程分为 4 个生涯阶段，每个阶段有不同的开发重点和协作原则。阶段信息由 PM 角色在 `docs/ROADMAP.md` 中维护，AI 在协作时应根据当前阶段调整工作方式。

### 阶段类型定义

项目生涯阶段按顺序演进，每个阶段都有明确的定义和规则：

### 原型验证 (demo)

**描述**: 快速验证核心概念和可行性

**阶段重点**:
- 快速迭代
- 概念验证
- 核心功能

**阶段原则**:
- 快速试错，快速调整
- 优先核心功能，暂缓优化
- 技术债务可接受，但需记录
- 详细的Git开发迭代记录
- 记录重要决定DECISIONS.md
- 建立 CI/CD

### 量产 (production)

**描述**: 产品化开发，准备规模化

**阶段重点**:
- 稳定性
- 性能优化
- 可维护性

**阶段原则**:
- 代码质量优先
- 建立发布和宣发预备, 指定和完善目标平台支持
- 启动前review全量代码，建立更稳定稳健的代码结构
- 完善QA产品测试覆盖
- 定义性能标准
- Unitest单元测试、检查规范
- 完善发布平台标准

### 商业化 (commercial)

**描述**: 面向市场，追求增长

**阶段重点**:
- 用户体验
- 市场适配
- 扩展性
- 插件化增量开发
- 数据热更

**阶段原则**:
- 用户反馈驱动
- 数据驱动决策
- 快速响应市场

### 稳定运营 (stable)

**描述**: 成熟产品，稳定维护

**阶段重点**:
- 稳定性
- 维护成本
- 长期规划

**阶段原则**:
- 变更需谨慎
- 向后兼容优先
- 文档完善

## 8.2 阶段化协作指导

AI 在协作时应：

1. **读取当前阶段**: 在对话开始时，读取 `docs/ROADMAP.md` 了解项目当前处于哪个阶段
2. **应用阶段规则**: 根据当前阶段的重点和原则调整工作方式
3. **关注阶段变化**: 当项目升级到新阶段时，注意新阶段的原则变化，调整协作方式
4. **阶段里程碑**: 关注当前阶段的里程碑完成情况，协助推进里程碑达成

> **重要**: 具体的当前阶段信息请查看 `docs/ROADMAP.md` 中的"当前项目生涯阶段"章节。

---

# 九、上下文管理

## 9.1 关键文件职责

| 文件 | 职责 | 更新时机 |
|-----|------|---------|
| `CONTRIBUTING_AI.md` | AI 协作规则，顶层指导 | 协作方式演进时 |
| `llms.txt` | 项目上下文摘要 (llmstxt.org 标准) | 项目信息变更时 |
| `docs/CONTEXT.md` | 当前开发上下文 | 每次对话结束时 |
| `docs/DECISIONS.md` | 重要决策记录 | 每次 S/A 级决策后 |
| `docs/CHANGELOG.md` | 版本变更日志 | 每次有效对话后 |
| `docs/QA_TEST_CASES.md` | 产品QA测试用例 | 每个功能完成时 |
| `docs/PRD.md` | 产品需求文档 | 需求变更时 |
| `docs/ROADMAP.md` | 路线图+迭代建议 | 里程碑规划/反馈时 |

## 9.2 上下文恢复协议

当开启新对话时，AI 应：
1. 读取 `CONTRIBUTING_AI.md` 了解协作规则
2. 读取 `docs/CONTEXT.md` 恢复当前状态
3. 读取 `docs/DECISIONS.md` 了解已确认和待定决策
4. 运行 `git log --oneline -10` 了解最近进展
5. 询问用户本次对话目标

## 9.3 上下文保存协议

每次对话结束时，AI 应：
1. 更新 `docs/CONTEXT.md` 保存当前状态
2. 更新 `docs/CHANGELOG.md` 记录本次产出
3. 如有新决策，更新 `docs/DECISIONS.md`
4. **必须执行 git commit** 记录本次对话产出

---

# 十、多开发者/Agent 协作协议

> **v0.5.0+ 支持多个开发者或多个 AI Agent 在同一项目中协同开发**

## 10.1 协作模式概述

VibeCollab 支持以下协作场景：
- 👥 **多人协作**: 多个开发者在同一项目上工作
- 🤖 **多 Agent 协作**: 多个 AI Agent 分工完成不同任务
- 🔀 **混合协作**: 人类开发者 + AI Agent 混合团队

### 核心原则

1. **独立工作空间**: 每个开发者维护自己的 `CONTEXT.md`，互不干扰
2. **智能聚合**: 系统自动聚合生成全局视图，提供整体状态
3. **明确协作关系**: 通过 `COLLABORATION.md` 记录任务依赖和交接
4. **自动身份识别**: 基于 Git 配置自动识别当前开发者
5. **冲突预防**: 提前检测潜在的跨开发者工作冲突

## 10.2 目录结构

多开发者模式下的项目结构：

```
project/
├── CONTRIBUTING_AI.md
├── project.yaml
└── docs/
    ├── CONTEXT.md            # 全局聚合视图（自动生成，只读）
    ├── CHANGELOG.md          # 全局变更日志
    ├── DECISIONS.md          # 全局决策记录
    └── developers/           # 开发者工作空间
        ├── COLLABORATION.md  # 协作关系文档
        ├── alice/            # 开发者 alice 的目录
        │   ├── CONTEXT.md    # alice 的工作上下文
        │   └── .metadata.yaml # 元数据（更新时间等）
        └── bob/              # 开发者 bob 的目录
            ├── CONTEXT.md
            └── .metadata.yaml
```

## 10.3 开发者身份识别

系统通过以下策略自动识别开发者身份：

**识别策略**:
- **主策略**: `git_username` 
  - `git_username`: 使用 `git config user.name`
  - `system_user`: 使用系统用户名（$USER / $USERNAME）
  - `manual`: 手动指定（通过环境变量 `VIBECOLLAB_DEVELOPER`）
- **降级策略**: `system_user` (主策略失败时使用)
- **名称标准化**: 开启 (小写、空格转下划线、移除特殊字符)

**使用 CLI 命令查看当前身份**:
```bash
vibecollab dev whoami
```

## 10.4 上下文管理

### 10.4.1 独立上下文

每个开发者维护自己的 `CONTEXT.md`，记录：
- 当前正在进行的任务
- 最近完成的工作
- 待解决的问题
- 技术债务

**更新命令**:
```bash
# 手动更新时间戳（通常在对话结束时自动执行）
vibecollab dev sync
```

### 10.4.2 全局上下文聚合

系统自动聚合所有开发者的上下文，生成全局视图（`docs/CONTEXT.md`）：

- ⚠️ **只读文件**: 不要手动编辑全局 CONTEXT.md
- 📊 **聚合内容**: 
  - 项目整体状态
  - 各开发者工作进展
  - 跨开发者依赖关系
  - 全局技术债务
- 🔄 **更新时机**: 对话结束时自动更新

**手动触发聚合**:
```bash
vibecollab dev sync --aggregate
```

## 10.5 协作文档管理

### 10.5.1 COLLABORATION.md

`docs/developers/COLLABORATION.md` 记录跨开发者的协作关系：

**包含内容**:
1. **任务分配矩阵**: 谁负责什么任务，谁是协作者
2. **依赖关系**: 任务之间的依赖关系
3. **交接记录**: 任务从一个开发者移交给另一个开发者
4. **协作约定**: 团队的协作惯例和规则

**示例格式**:
```markdown
## 任务分配矩阵

| 任务 | 负责人 | 协作者 | 状态 | 依赖 |
|------|--------|--------|------|------|
| TASK-DEV-001: 用户认证 | alice | bob | IN_PROGRESS | - |
| TASK-DEV-002: 数据库设计 | bob | - | DONE | - |
| TASK-DEV-003: API 开发 | alice | - | TODO | TASK-DEV-002 |

## 交接记录

### TASK-DEV-001: 用户认证
- **交接时间**: 2026-02-10 14:30
- **交接人**: bob
- **接收人**: alice
- **交接原因**: bob 完成数据库设计，alice 接手前端集成
- **交接说明**: API 接口已完成，文档见 docs/api.md
```

### 10.5.2 查看协作状态

```bash
# 查看所有开发者状态
vibecollab dev list

# 查看特定开发者状态
vibecollab dev status alice

# 初始化新开发者上下文
vibecollab dev init --developer bob
```

## 10.6 对话流程适配

### 10.6.1 对话开始时

多开发者模式下，AI 在对话开始时应：

```
1. 读取全局聚合 CONTEXT.md（了解整体状态）
2. 读取当前开发者的 CONTEXT.md（了解自己的进度）
3. 读取 COLLABORATION.md（了解协作关系）
4. 识别当前开发者身份（vibecollab dev whoami）
5. 确认本次对话目标
```

### 10.6.2 对话结束时

```
1. 更新当前开发者的 CONTEXT.md
2. 更新全局 CHANGELOG.md
3. 如有跨开发者协作，更新 COLLABORATION.md
4. 自动触发上下文聚合（生成新的全局 CONTEXT.md）
5. Git commit（记录当前开发者的提交）
```

### 10.6.3 多开发者场景的特殊考虑

**场景一：任务依赖**
- Alice 的任务依赖 Bob 的任务完成
- AI 应在 COLLABORATION.md 中标注依赖关系
- Alice 开始工作前检查依赖任务状态

**场景二：任务交接**
- Bob 完成阶段性工作，交接给 Alice
- 在 COLLABORATION.md 记录交接信息
- Alice 接手时读取交接说明

**场景三：并行开发**
- Alice 和 Bob 同时开发不同模块
- 各自维护独立的 CONTEXT.md
- 通过全局聚合了解对方进展

## 10.7 冲突检测与预防 (v0.5.1+)

> **新特性：自动检测跨开发者的潜在工作冲突**

### 10.7.1 冲突类型

系统会检测以下类型的冲突：

1. **文件冲突**: 多个开发者同时修改同一文件
2. **任务冲突**: 多个开发者负责相同或重叠的任务
3. **依赖冲突**: 任务依赖关系不一致或循环依赖
4. **命名冲突**: 多个开发者创建同名的函数/类/模块

### 10.7.2 冲突检测命令

```bash
# 检测当前开发者与其他开发者的冲突
vibecollab dev conflicts

# 详细模式（显示冲突详情）
vibecollab dev conflicts --verbose

# 检测特定开发者之间的冲突
vibecollab dev conflicts --between alice bob
```

### 10.7.3 冲突处理流程

```
1. [AI] 检测到潜在冲突
2. [AI] 在 CONTEXT.md 中标注冲突提醒
3. [AI] 提示用户检查冲突详情
4. [人] 决定处理方式：
   - 协调分工
   - 合并工作
   - 重新分配任务
5. [AI] 更新 COLLABORATION.md 记录解决方案
```

### 10.7.4 冲突预防建议

- ✅ 明确任务边界，避免职责重叠
- ✅ 及时更新 COLLABORATION.md 的任务分配
- ✅ 使用任务依赖标注避免循环依赖
- ✅ 定期执行 `vibecollab dev conflicts` 检查
- ✅ 重要修改前查看全局 CONTEXT.md 了解他人进展

## 10.8 CLI 命令参考

```bash
# 开发者身份
vibecollab dev whoami                    # 查看当前开发者身份

# 开发者管理
vibecollab dev list                      # 列出所有开发者
vibecollab dev status <developer>        # 查看开发者状态
vibecollab dev init --developer <name>   # 初始化新开发者

# 上下文同步
vibecollab dev sync                      # 更新元数据时间戳
vibecollab dev sync --aggregate          # 重新生成全局聚合

# 冲突检测 (v0.5.1+)
vibecollab dev conflicts                 # 检测冲突
vibecollab dev conflicts --verbose       # 详细冲突报告
```

## 10.9 最佳实践

### 对于 AI Agent

1. **对话开始时**: 始终先执行 `vibecollab dev whoami` 确认身份
2. **上下文恢复**: 同时读取全局和个人 CONTEXT.md
3. **协作意识**: 修改共享资源前检查 COLLABORATION.md
4. **及时同步**: 对话结束时更新上下文并触发聚合
5. **冲突敏感**: 发现潜在冲突立即提醒用户

### 对于人类开发者

1. **明确分工**: 在 COLLABORATION.md 中清晰记录任务分配
2. **定期同步**: 经常查看全局 CONTEXT.md 了解团队进展
3. **交接规范**: 任务交接时详细记录背景和状态
4. **冲突检查**: 重大变更前执行冲突检测
5. **文档及时性**: 完成阶段性工作及时更新个人 CONTEXT.md

### 迁移单开发者项目

如果项目原本是单开发者模式，可以平滑迁移：

```bash
# 方式一：使用 CLI 命令
vibecollab dev migrate

# 方式二：在 project.yaml 中启用
multi_developer:
  enabled: true

# 然后重新生成协议文档
vibecollab generate
```

迁移后：
- 原 `docs/CONTEXT.md` 会备份为 `docs/CONTEXT.md.backup`
- 创建 `docs/developers/{developer}/CONTEXT.md`
- 自动生成新的全局聚合 `docs/CONTEXT.md`

---

# Prompt 工程最佳实践

## 有效提问模板

### 协议设计讨论
```
[DESIGN] 我想讨论{系统名称}的设计
当前想法是: {描述}
主要顾虑: {顾虑}
请从用户体验角度分析

```

### 架构讨论
```
[ARCH] 我需要设计{模块名}的架构
需求: {功能需求}
约束: {性能/兼容性约束}
请给出2-3个方案对比

```

### 开发讨论
```
[DEV] 请实现{功能}
输入: {输入描述}
输出: {期望输出}
相关文件: {文件路径}

```

### 项目管理讨论
```
[PM] 请帮我{任务描述}
```

### 问题诊断
```
[QA] 遇到问题: {问题描述}
复现步骤: {步骤}
期望行为: {期望}
实际行为: {实际}
```

## 高价值引导词

| 场景 | 引导词 |
|-----|-------|
| 深入分析 | "请从{角色}视角分析"、"有哪些我没考虑到的" |
| 方案对比 | "给出2-3个方案并对比优劣" |
| 风险评估 | "这个方案最大的风险是什么" |
| 简化问题 | "MVP版本最少需要什么" |
| 扩展思考 | "如果未来要支持{X}，现在要预留什么" |
| Vibe 对齐 | "你理解我的意图了吗"、"我们先对齐一下理解" |

## Vibe Development 沟通技巧

### 不要说
- "帮我写一个XXX" (太直接，跳过思考)
- "直接给我代码" (跳过设计讨论)

### 推荐说
- "我想和你讨论一下XXX的设计"
- "你觉得这个方案有什么问题"
- "我们先对齐一下理解，再动手"
- "这个决策你怎么看"
- "把你的思考过程告诉我"

---

# 十一、符号学标注系统

本协议使用统一的符号体系确保沟通一致性：

## Decision Status

| 符号 | 含义 |
|------|------|
| `PENDING` | 待确认 |
| `CONFIRMED` | 已确认 |
| `REVISED` | 已修订 |

## Task Status

| 符号 | 含义 |
|------|------|
| `TODO` | 待开始 |
| `IN_PROGRESS` | 进行中 |
| `REVIEW` | 待审核 |
| `DONE` | 已完成 |

## Test Status

| 符号 | 含义 |
|------|------|
| `🟢` | 通过 |
| `🟡` | 部分通过 |
| `🔴` | 未通过 |
| `⚪` | 跳过 |

## Priority

| 符号 | 含义 |
|------|------|
| `P0` | 最高优先级/阻断 |
| `P1` | 高优先级 |
| `P2` | 中优先级 |
| `P3` | 低优先级 |

---

# 已确认决策汇总

| ID | 决策 | 选择 | 理由 |
|----|------|------|------|
| 001 | YAML 配置驱动 | YAML + Jinja2 模板 | 可读性强，易于扩展 |
| 002 | 扩展机制 | 钩子 + 上下文注入 | 解耦核心和领域特定逻辑 |
| 003 | CLI 框架 | Click | 轻量、Pythonic |

---

# 十二、协议自检机制

## 12.1 协议自检的重要性

> **使用协议时常常发现，有时候对话时会漏掉一些东西，比如没有记得提交 git，没有记得及时同步某个对应文档.md。**

协议自检机制帮助 AI 和用户确保遵循了协作协议中的各项要求。

## 12.2 自检触发方式

### 方式一：命令行检查

```bash
# 检查协议遵循情况
vibecollab check

# 严格模式（警告也视为失败）
vibecollab check --strict
```

### 方式二：对话中触发

在对话中使用以下触发词，AI 应主动执行协议自检：

- "检查协议"
- "协议自检"
- "检查是否遵循协议"
- "protocol check"
- "自检"

## 12.3 检查项说明

协议检查器会检查以下内容：

### Git 协议检查
- ✅ 项目是否已初始化 Git 仓库
- ✅ 是否有未提交的更改
- ⚠️  Git 提交频率（提醒长时间未提交）

### 文档更新检查
- ✅ 必需文档是否存在（CONTEXT.md, CHANGELOG.md 等）
- ⚠️  文档是否及时更新（24小时内）
- ✅ PRD.md 是否存在（如果启用）

### 对话流程检查
- ✅ 对话开始时应该读取的文件是否存在
- ✅ 对话结束时应该更新的文件是否存在

## 12.4 检查结果说明

检查结果分为三个级别：

| 级别 | 符号 | 说明 | 处理方式 |
|------|------|------|---------|
| **错误** | ❌ | 违反协议要求 | 必须修复 |
| **警告** | ⚠️  | 可能遗漏的协议步骤 | 建议处理 |
| **信息** | ℹ️  | 提醒信息 | 可选择性处理 |

## 12.5 AI 自检行为规范

当用户触发协议自检时，AI 应：

1. **执行检查**: 运行协议检查器，获取检查结果
2. **展示结果**: 清晰展示所有检查项的状态
3. **提供建议**: 对于未通过的检查项，提供具体的修复建议
4. **主动修复**: 对于可以自动修复的问题（如更新文档），主动执行修复
5. **记录提醒**: 对于需要人工处理的问题，明确提醒用户

## 12.6 自检最佳实践

### 对话开始时
- 在恢复上下文后，可以执行一次快速自检，确保环境正常

### 对话结束时
- 在执行 git commit 前，执行自检确保所有协议要求都已满足

### 定期检查
- 如果长时间未对话，重新开始对话时执行完整自检

---


# 十三、产品需求文档 (PRD) 管理

## 13.1 PRD 的作用

> **我们虽然是一个启发式对话，需求在对话中推进，不过我们目前没有一个记录原始需求和变化的 PRD.md。我认为项目需求也在随着对话变化和成长。**

PRD.md 用于：
- 📝 **记录原始需求**: 保存用户最初提出的需求描述
- 📊 **跟踪需求变化**: 记录需求在对话中的演进过程
- 🔍 **需求追溯**: 了解每个需求从提出到实现的完整历程
- 📈 **需求统计**: 了解项目需求的状态分布

## 13.2 PRD 文档结构

PRD.md 位于 `docs/PRD.md`，包含以下内容：

### 需求列表

每个需求包含：
- **需求 ID**: REQ-001, REQ-002, ...
- **需求标题**: 简洁的需求名称
- **原始描述**: 用户最初提出的需求描述
- **当前描述**: 经过澄清和演进后的需求描述
- **状态**: draft / confirmed / in_progress / completed / cancelled
- **优先级**: high / medium / low
- **创建时间**: 需求首次记录的时间
- **更新时间**: 需求最后修改的时间
- **需求变化历史**: 记录需求描述的变化轨迹

### 需求统计

自动统计各状态需求的数量。

## 13.3 PRD 使用流程

### 需求提出阶段

1. **用户提出需求**: 在对话中描述需求
2. **AI 记录需求**: 
   - 使用需求澄清协议，将模糊描述转化为结构化需求
   - 在 PRD.md 中创建新需求条目（REQ-XXX）
   - 记录原始描述和当前描述

### 需求演进阶段

1. **需求澄清**: 在对话中进一步明确需求细节
2. **更新 PRD**: 
   - 更新需求的当前描述
   - 在变化历史中记录变化原因
   - 更新需求状态（如从 draft → confirmed）

### 需求实现阶段

1. **开始实现**: 将需求状态更新为 in_progress
2. **完成实现**: 将需求状态更新为 completed
3. **记录关联**: 在需求中关联对应的 TASK-ID

## 13.4 PRD 管理触发词

在对话中使用以下触发词，AI 应主动管理 PRD：

- "记录需求"
- "更新 PRD"
- "查看需求"
- "需求状态"
- "PRD"
- "需求文档"

## 13.5 PRD 与需求澄清协议的关系

PRD 是需求澄清协议的**输出产物**：

```
用户提出需求
    ↓
需求澄清协议（结构化需求）
    ↓
记录到 PRD.md
    ↓
需求演进和实现
```

## 13.6 PRD 更新时机

AI 应在以下时机更新 PRD：

1. **新需求提出时**: 创建新需求条目
2. **需求澄清后**: 更新当前描述和变化历史
3. **需求状态变化时**: 更新状态字段
4. **需求实现完成时**: 更新状态为 completed，关联 TASK-ID

## 13.7 PRD 最佳实践

### 需求描述规范
- **原始描述**: 保持用户原话，不做修改
- **当前描述**: 经过澄清后的结构化描述
- **变化原因**: 清晰说明为什么需求发生变化

### 需求状态流转
```
draft → confirmed → in_progress → completed
  ↓                    ↓
cancelled          cancelled
```

### 需求关联
- 需求可以关联到 TASK-ID
- 一个需求可能对应多个任务
- 在需求中记录关联的任务 ID

---


# 十四、快速参考

## 开始新对话时说

```
继续项目开发。
请先读取 CONTRIBUTING_AI.md 和 docs/CONTEXT.md 恢复上下文。
本次对话目标: {你的目标}
```

## 结束对话前说

```
请更新 docs/CONTEXT.md 保存当前进度。
总结本次对话的决策和产出。
然后 git commit 记录本次对话。
```

## 协议自检触发

```
检查协议
或
协议自检
或
vibecollab check
```

## Vibe Check

```
在继续之前，确认一下：
- 我们对齐理解了吗？
- 这个方向对吗？
- 有什么我没考虑到的？
```

---

# CONTRIBUTING_AI.md 迭代日志

| 版本 | 日期 | 变更内容 |
|-----|------|---------|
| v1.0 | 2026-02-10 | 初始版本 |

---

# Git 提交历史参考

本项目的 Git 历史记录了完整的设计演进过程：

```bash
# 查看提交历史
git log --oneline

# 查看某次提交详情
git show <commit-hash>

# 查看文件变更历史
git log --follow -p <file>
```

---


*本文档是活文档，记录人机协作的演进过程。*
*生成时间: 2026-02-10 23:31:54*
*最珍贵的不是结果，而是我们共同思考的旅程。*
